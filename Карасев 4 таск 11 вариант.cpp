#include <iostream>
#include <cstdlib>
 
using namespace std;
 
double sumN(double x, int n, double& last)
{
double sum = 1;
 
last = -x;
 
double ratio = -x; // Отношение i-ого слагаемого к i-1 слагаемому.
 
for (int i = 1; i < n; i++)
{
sum += last;
 
last = last * ratio;
}
 
return sum;
}
 
double sumE(double x, double E, double& n )
{
double sum = 1;
 
double last = -x;
 
double ratio = -x; // Отношение i-ого слагаемого к i-1 слагаемому.
 
 
for ( n= 1; fabs(last) > fabs(E); n++)
{
sum += last;
 
last = last * ratio;
}
 
 
return sum;
 
}
 
int main()
{
 
setlocale(LC_ALL, "Rus");
 
while (1)
{
system("pause");
 
system("cls"); // Очищает поле консоли после каждой выполненной итерации цикла while. //
 
int z = 0;
 
cout « " Выберите действие : \n \n \t 1. Выполнить программу. \n \n \t 2. Выйти из программы. \n \n Действие : ";
 
cin » z;
 
if (z != 1)
{
break;
}
 
double x, func, sum, abs_error, fractpart, n, intpart;
 
bool f;
 
cout « " \n Задание № 1 : " « endl;
// Проверка на принадлежность значения введённого аргумента к радиусу сходимости функции.
do
{
cout « " \n Введите значение аргумента из области сходимости функции R = (-1 ; 1) : ";
 
cin » x;
 
} while (x < -1 || x > 1);
 
func = 1 / (1 + x);
 
cout « func « endl;
 
cout « " \n Введите число слагаемых ряда : ";
 
cin » n;
 
do
{
f = false;
 
fractpart = modf(n, &intpart); // С помощью функции modf отделяем целую часть от дробной числа n. Переменной fractpart присваивается дробное значение, а переменной intpart - целое.
 
if (fractpart == 0 && intpart > 0) // Если значение дробной части числа n равно нулю, а значение целой части строго больше нуля, то число n есть натурально число.
{
f = true; // Переприсваиваем значение булевой переменной, чтобы выйти из тела цикла.
 
n = intpart; // Присваем переменной n обратно своё значение, ранее помещённое в переменную intpart функцией modf.
 
}
else
{
cout « " \n Вы ввели не натуральное значение n ! \n \n Введите значение n повторно : "; /* В противном случае просим пользователя вновь ввести значение n.
Программа будет требовать пользователя вновь ввести значение переменной n до тех пор,
пока тот ни введёт значение n, согласно заданным условиям. */
 
cin » n;
}
} while (!f);
 
double last;
 
sum = sumN(x, n, last);
 
abs_error = fabs(func - sum);
 
cout « " \n Значение суммы частичного ряда равно " « sum « endl;
 
cout « " \n Абсолютная погрешность полученного результата равна : " « abs_error « endl;
 
if (abs_error < fabs(last))
{
cout « " \n Абсолютная величина последнего (N-го) слагаемого, включенного в частичную сумму больше абсолютной погрешности." « endl;
 
}
 
else if (abs_error > fabs(last))
{
cout « " \n Абсолютная величина последнего (N-го) слагаемого, включенного в частичную сумму меньше абсолютной погрешности." « endl;
}
 
else
{
cout « " \n Абсолютная величина последнего (N-го) слагаемого, включенного в частичную сумму равна абсолютной погрешности. \n " « endl;
}
 
system("pause");
 
cout « " \n \n Задание № 2 : " « endl;
 
double E;
 
do
{
cout « " \n Введите значение аргумента из радиуса сходимости функции R = (-1 : 1) : ";
 
cin » x;
 
} while (x < -1 || x > 1);
 
func = 1 / (1 + x);
 
cout « " \n Укажите точность вычислений : ";
 
cin » E;
 
 
while (fabs(x) <= fabs(E))
{
cout « " \n Введённое вами значение аргумента не превышает указанную точность вычислений из-за чего могут возникнуть некоторые неточности в вычислениях. \n Измените значение аргумента функции или укажите другую точность вычислений. " « endl;
 
cout « " \n Выберите повторно точность вычислений : ";
 
cin » E;
 
do
{
cout « " \n Введите повторно значение аргумента из области сходимости функции R = (-1 : 1) : ";
 
cin
» x;
 
} while (x < -1 || x > 1);
 
}
 
 
 
cout « " \n Точное значение функции равно : " « func « endl;
 
cout « " \n Частичная сумма ряда с заданной точностью равна : " « sumE(x, E, n);
 
cout « " \n \n Количество слагаемых числового ряда, превосходящих по значению заданную точность E : " « n « endl;
 
sum = sumE(x, E / 10, n);
 
cout « " \n \n Частичная сумма ряда с точностью. превосходящей заданную в 10 раз, равна : " « sum « endl;
 
cout « " \n \n Количество слагаемых числового ряда, превосходящих по значению заданную точность E : " « n « endl;
 
}
 
}
